name: Build container image with cache
run-name: Build container image with cache ${{ github.ref_name }}

on:
  workflow_call:
    inputs:
      image:
        description: 'Set the tag of the docker image'
        required: true
        type: string
      tags:
        description: 'Set the tag of the docker image'
        required: false
        type: string
      registry:
        description: 'Set the image registry repository name, default is frontegg'
        required: false
        default: 'frontegg'
        type: string
      image_file_path:
        description: 'Set the image build file path, for example ./Dockerfile'
        required: false
        default: './Dockerfile'
        type: string
    secrets:
      npm_token:
        description: 'Npm Token'
        required: true
      docker_hub_password:
        description: 'Docker Hub Password'
        required: true
      docker_hub_user:
        description: 'Docker Hub User'
        required: true


jobs:
  build-and-push-docker:
    name: Build and Push Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Checkout Workflows
        uses: actions/checkout@v4
        with:
          repository: frontegg/workflows
          path: workflows
          clean: false
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.docker_hub_user }}
          password: ${{ secrets.docker_hub_password }}
      - name: Prepare image tags
        uses: actions/github-script@v6
        id: 'image-tags'
        with:
          result-encoding: json
          script: |
            const inputs = ${{ toJSON(inputs) }};
            const repositoryName = inputs.registry || 'frontegg';
            const imageName = `${repositoryName}/${inputs.image}`;
            const tags = inputs.tags.split("\n")
                              .map(s => s.replace(/^!\s+/, "!").trim())
                              .filter(x => x !== "")
                              .map(s => `${imageName}:${s}`);
            const latestTag = `${imageName}:latest`;
            return { tags, primaryTag: tags[0] || latestTag, latestTag, imageName };
      - name: Check if Docker Image exists
        id: check-image
        run: |
          PRIMARY_TAG="${{ fromJSON(steps.image-tags.outputs.result).primaryTag }}"
          LATEST_TAG="${{ fromJSON(steps.image-tags.outputs.result).latestTag }}"
          IMAGE_NAME="${{ fromJSON(steps.image-tags.outputs.result).imageName }}"
          
          echo "Checking if image $PRIMARY_TAG exists..."
          if docker manifest inspect "$PRIMARY_TAG" > /dev/null 2>&1; then
            echo "✓ Docker image $PRIMARY_TAG exists, skipping build"
            echo "image-exists=true" >> $GITHUB_OUTPUT
            echo "use-latest=false" >> $GITHUB_OUTPUT
          elif docker manifest inspect "$LATEST_TAG" > /dev/null 2>&1; then
            echo "✓ Docker image $PRIMARY_TAG does not exist, but $LATEST_TAG exists"
            echo "Will tag $LATEST_TAG as $PRIMARY_TAG instead of rebuilding"
            echo "image-exists=false" >> $GITHUB_OUTPUT
            echo "use-latest=true" >> $GITHUB_OUTPUT
          else
            echo "✗ Docker image $PRIMARY_TAG does not exist, will build with cache"
            echo "image-exists=false" >> $GITHUB_OUTPUT
            echo "use-latest=false" >> $GITHUB_OUTPUT
            echo "Note: Even if image doesn't exist, Docker layer cache will speed up the build"
          fi
      - name: Tag latest image as new tag
        if: steps.check-image.outputs.use-latest == 'true'
        run: |
          PRIMARY_TAG="${{ fromJSON(steps.image-tags.outputs.result).primaryTag }}"
          LATEST_TAG="${{ fromJSON(steps.image-tags.outputs.result).latestTag }}"
          echo "Tagging $LATEST_TAG as $PRIMARY_TAG..."
          docker pull "$LATEST_TAG"
          docker tag "$LATEST_TAG" "$PRIMARY_TAG"
          docker push "$PRIMARY_TAG"
          echo "✓ Successfully tagged and pushed $PRIMARY_TAG from $LATEST_TAG"
      - name: Run build and push docker image action
        if: steps.check-image.outputs.image-exists != 'true' && steps.check-image.outputs.use-latest != 'true'
        uses: ./workflows/.github/shared-actions/build-publish-image
        with:
          image: ${{ inputs.image }}
          tags: ${{ inputs.tags }}
          registry: ${{ inputs.registry }}
          image_file_path: ${{ inputs.image_file_path }}
          npm_token: ${{ secrets.npm_token }}
          docker_hub_user: ${{ secrets.docker_hub_user }}
          docker_hub_password: ${{ secrets.docker_hub_password }}
      - name: Update latest tag after build
        if: steps.check-image.outputs.image-exists != 'true' && steps.check-image.outputs.use-latest != 'true'
        run: |
          PRIMARY_TAG="${{ fromJSON(steps.image-tags.outputs.result).primaryTag }}"
          LATEST_TAG="${{ fromJSON(steps.image-tags.outputs.result).latestTag }}"
          if [ "$PRIMARY_TAG" != "$LATEST_TAG" ]; then
            echo "Updating $LATEST_TAG to point to $PRIMARY_TAG..."
            docker pull "$PRIMARY_TAG"
            docker tag "$PRIMARY_TAG" "$LATEST_TAG"
            docker push "$LATEST_TAG"
            echo "✓ Successfully updated $LATEST_TAG"
          else
            echo "Primary tag is already latest, no update needed"
          fi